# -*- coding: utf-8 -*-
"""part1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1NKfSifY-a879Hvh77QZzTRaSvvjskXqI

# Problem 1
"""

# Commented out IPython magic to ensure Python compatibility.
from mpl_toolkits import mplot3d

import numpy as np
import matplotlib.pyplot as plt
# %matplotlib inline

"""## Functions in R"""

class GradientDescent():
  
  def __init__(self, f, f_prime, lr, x_init, a_init, b_init):
    self.f = f
    self.f_prime = f_prime
    self.xs = [x_init]
    self.a = a_init
    self.b = b_init
    self.lr = lr
  
  def step(self, num_steps=1):
    for _ in range(num_steps):
      x = self.xs[-1]
    
      # one step of gradient descent
      x = x - self.lr * self.f_prime(x)
    
      # update
      self.xs.append(x)
      self.a = min(self.xs[-1], self.a)
      self.b = max(self.xs[-1], self.b)
    
  def plot(self):
     
    fig, ax = plt.subplots(1, 1, figsize=(8, 8))
    ax.grid(True)
    
    # plot function
    x_axis = np.linspace(self.a, self.b)
    ax.plot(x_axis, [self.f(x) for x in x_axis])
    
    # plot all points encountered during gradient descent
    ax.scatter(self.xs, [self.f(x) for x in self.xs])

GD1 = GradientDescent(f_1, f_1_prime, lr=1.0, x_init=0.0, a_init=-4.0, b_init=4.0)
GD2 = GradientDescent(f_2, f_2_prime, lr=1.0, x_init=0.0, a_init=-4.0, b_init=4.0)
GD3 = GradientDescent(f_3, f_3_prime, lr=1.0, x_init=0.0, a_init=-4.0, b_init=4.0)

GD1.plot()

GD2.plot()

GD3.plot()

"""## Functions with local extrema in R^2"""

def f_1(x, y):
    return np.sin(np.sqrt(x ** 2 + y ** 2))
def f_1dx(x,y):
  return x*np.cos(np.sqrt(x**2+y**2))/np.sqrt(x**2+y**2)
def f_1dy(x,y):
  return y*np.cos(np.sqrt(x**2+y**2))/np.sqrt(x**2+y**2)
def f_2(x,y):
  return x**2/9+y**2/16
def f_2dx(x,y):
  return 2*x/9
def f_2dy(x,y):
  return 2*y/16
def f_3(x,y):
  return np.sin(x)*y**3
def f_3dx(x,y):
  return y**3 * np.cos(x)
def f_3dy(x,y):
  return 3*y **2 * np.sin(x)

def plotFunction(f):
  fig = plt.figure()
  ax = plt.axes(projection="3d")

  x = np.linspace(-6, 6, 30)
  y = np.linspace(-6, 6, 30)

  X, Y = np.meshgrid(x, y)
  Z = f(X, Y)

  fig = plt.figure()
  ax.plot_surface(X, Y, Z, rstride=1, cstride=1,
                  cmap='winter', edgecolor='none')
  ax.set_title('surface');

  plt.show()

def plotGrad(fdx, fdy):
  X = np.arange(-10, 10, 1)
  Y = np.arange(-10, 10, 1)
  U, V = np.meshgrid(fdx(X,Y), fdy(X,Y))

  fig, ax = plt.subplots()
  q = ax.quiver(X, Y, U, V)
  ax.quiverkey(q, X=0.3, Y=1.1, U=10,
               label='Quiver key, length = 10', labelpos='E')

  plt.show()

"""## Functions in R^2 with quiver plot"""

plotFunction(f_1)
plotGrad(f_2dx,f_2dy)

plotFunction(f_2)
plotGrad(f_2dx,f_2dy)

plotFunction(f_3)
plotGrad(f_3dx,f_3dy)

